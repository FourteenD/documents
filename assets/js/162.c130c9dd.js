(window.webpackJsonp=window.webpackJsonp||[]).push([[162],{611:function(e,t,a){"use strict";a.r(t);var s=a(31),r=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"cluster"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cluster"}},[e._v("#")]),e._v(" Cluster")]),e._v(" "),a("p",[e._v("Cluster 是计算、存储和网络资源的集合，Kubernetes 允许以 “抽象的形式” 将容器化的应用部署到集群，而无需将它们指定到某个特定的独立的计算机。")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://d33wubrfki0l68.cloudfront.net/283cc20bb49089cb2ca54d51b4ac27720c1a7902/34424/docs/tutorials/kubernetes-basics/public/images/module_01_cluster.svg",alt:"img"}})]),e._v(" "),a("h2",{attrs:{id:"master"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#master"}},[e._v("#")]),e._v(" Master")]),e._v(" "),a("p",[e._v("Master 的职责是调度整个 Cluster。Master 协调 Cluster 中的所有活动，例如调度应用、维护应用的所需状态、应用扩容以及推出新的更新。")]),e._v(" "),a("h2",{attrs:{id:"node"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#node"}},[e._v("#")]),e._v(" Node")]),e._v(" "),a("p",[e._v("Node 的职责是运行容器化的应用。Node 是一个物理机或 VM，每个 Node 都有 Kubelet，它管理 Node 并且是 Node 与 Master 通信的代理。")]),e._v(" "),a("h2",{attrs:{id:"pod"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#pod"}},[e._v("#")]),e._v(" Pod")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://d33wubrfki0l68.cloudfront.net/5cb72d407cbe2755e581b6de757e0d81760d5b86/a9df9/docs/tutorials/kubernetes-basics/public/images/module_03_nodes.svg",alt:"img"}})]),e._v(" "),a("p",[e._v("Pod 是 Kubernetes 的最小工作单元。每个 Pod 包含一个或多个容器。Pod 中的容器会作为一个整体被 Master 调度到一个 Node 上运行。")]),e._v(" "),a("p",[e._v("Kubernetes 引入 Pod 主要基于下面两个目的：")]),e._v(" "),a("ol",[a("li",[a("p",[e._v("可管理性：")]),e._v(" "),a("p",[e._v("有些容器天生就是需要紧密联系，一起工作。Pod 提供了比容器更高层次的抽象，将它们封装到一个部署单元中。Kubernetes 以 Pod 为最小单位进行调度、扩展、共享资源、管理生命周期。")])]),e._v(" "),a("li",[a("p",[e._v("通信和资源共享：")]),e._v(" "),a("p",[e._v("Pod 中的所有容器使用同一个网络 namespace，即相同的 IP 地址和 Port 空间。它们可以直接用 localhost 通信。同样的，这些容器可以共享存储，当 Kubernetes 挂在 volume 到 Pod，本质上是将 volume 挂载到 Pod 中的每一个容器。")])])]),e._v(" "),a("p",[e._v("Pods 有两种使用方式：")]),e._v(" "),a("ol",[a("li",[e._v("运行单一容器")]),e._v(" "),a("li",[e._v("运行多个容器")])]),e._v(" "),a("h2",{attrs:{id:"controller"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#controller"}},[e._v("#")]),e._v(" Controller")]),e._v(" "),a("p",[e._v("Kubernetes 通常不会直接创建 Pod，而是通过 Controller 来管理 Pod 的。Controller 中定义了 Pod 的部署特性，比如有几个副本，在什么样的 Node 上运行等。为了满足不同的业务场景，Kubernetes 提供了多种 Controller，包括 Deployment、ReplicaSet、DaemonSet、StatefulSet、Job 等。")]),e._v(" "),a("h3",{attrs:{id:"deployment"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#deployment"}},[e._v("#")]),e._v(" Deployment")]),e._v(" "),a("p",[e._v("Deployment 是最常用的 Controller，Deployment 可以管理 Pod 的多个副本，并确保 Pod 按照期望的状态运行。")]),e._v(" "),a("h3",{attrs:{id:"replicaset"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#replicaset"}},[e._v("#")]),e._v(" ReplicaSet")]),e._v(" "),a("p",[e._v("ReplicaSet 实现了 Pod 的多副本管理。使用 Deployment 时自动创建 ReplicaSet，也就是说 Deployment 是通过 ReplicaSet 来管理 Pod 的多个副本的，我们通常不需要直接使用 ReplicaSet。")]),e._v(" "),a("h3",{attrs:{id:"daemonset"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#daemonset"}},[e._v("#")]),e._v(" DaemonSet")]),e._v(" "),a("p",[e._v("DaemonSet 用于每个 Node 最多只运行一个 Pod 的场景，而其通常用于运行 daemon。")]),e._v(" "),a("h3",{attrs:{id:"statefulset"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#statefulset"}},[e._v("#")]),e._v(" StatefulSet")]),e._v(" "),a("p",[e._v("StatefulSet 能够保证 Pod 的每个副本在整个生命周期中的名称是不变的，而其他 Controller 不提供这个功能。当某个 Pod 发生故障需要删除并重新启动时，Pod 的名称会发生变化，同时 StatefulSet 会保证副本按照固定的顺序启动、更新或删除。")]),e._v(" "),a("h3",{attrs:{id:"job"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#job"}},[e._v("#")]),e._v(" Job")]),e._v(" "),a("p",[e._v("Job 用于运行结束就删除的应用。")]),e._v(" "),a("h2",{attrs:{id:"service"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#service"}},[e._v("#")]),e._v(" Service")]),e._v(" "),a("p",[e._v("Deployment 可以部署多个副本，每个 Pod 都有自己的 IP，外界如何访问这些副本的 IP 呢？要知道 Pod 很可能会被频繁的销毁和重启，它们的 IP 也会随之变化，用 IP 来访问很不现实。")]),e._v(" "),a("p",[e._v("如果在 Pod 前增加一个 Service 则可以很好的解决这个问题，只需要去访问 Service 的 IP 及 Port 即可。")]),e._v(" "),a("p",[e._v("故，Kubernetes 运行容器与访问容器分别由 Controller 和 Service 执行。")]),e._v(" "),a("h2",{attrs:{id:"namespace"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#namespace"}},[e._v("#")]),e._v(" Namespace")]),e._v(" "),a("p",[e._v("如果有多个用户或项目组使用同一个 Kubernetes Cluster，如何将他们创建的 Controller、Pod 等资源分开呢？")]),e._v(" "),a("p",[e._v("Namespace 可以将一个物理的 Cluuster 逻辑划分为多个虚拟的 Cluster，每个 Cluster 就是一个 Namespace。不同的 Namespace 里的资源是完全隔离的。")]),e._v(" "),a("p",[e._v("Kubernetes 默认创建了两个 Namespace "),a("code",[e._v("default")]),e._v(" 和 "),a("code",[e._v("kube-system")]),e._v("。创建资源时如果不指定，将被放到 "),a("code",[e._v("default")]),e._v(" 中，Kubernetes 自己创建的系统资源将放到 "),a("code",[e._v("kube-system")]),e._v(" 中。")])])}),[],!1,null,null,null);t.default=r.exports}}]);